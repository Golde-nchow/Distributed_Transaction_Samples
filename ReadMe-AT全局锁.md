#### 参考
感兴趣的可以直接看 Seata 官方文档，写得不错：https://seata.io/zh-cn/docs/overview/what-is-seata.html

#
#### 写隔离
````
1、一阶段本地事务提交前，需要确保先拿到 全局锁

2、拿不到 全局锁 ，不能提交本地事务

3、tx1 先开始，开启本地事务，拿到本地锁。

4、本地事务提交前，先拿到该记录的 全局锁 ，本地提交释放本地锁

5、tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 全局锁

6、如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚

7、因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 脏写 的问题

````
![avatar](images/lock/第一阶段写隔离.png)


![avatar](images/lock/第二阶段写隔离.png)


#### 读隔离
````
1、Seata（AT 模式）的默认全局隔离级别是 读未提交

2、目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理

3、SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁并重试

4、这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回
````

![avatar](images/lock/读隔离.png)
